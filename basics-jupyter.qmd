---
title: "Diabetes Logistic Regression"
format: 
  html:
    code-fold: false
jupyter: python3
---

## Logistic regression
 
Using Logistic regression as a classifier (Machine Learning) 
 
 
```{python}
from ucimlrepo import fetch_ucirepo 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from collections import Counter
```

```{python}
#| label: fig-polar
#| fig-cap: "A line plot on a polar axis"

import numpy as np
import matplotlib.pyplot as plt

r = np.arange(0, 2, 0.01)
theta = 2 * np.pi * r
fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
ax.plot(theta, r)
ax.set_rticks([0.5, 1, 1.5, 2])
ax.grid(True)
plt.show()
```

```{python}
# Exploratory data analysis 

def eda (df):
    head = df.head()
    shape = df.shape
    missing_values = df.isnull().sum()
    return head, shape, missing_values

def prepData (data_file, 
              y_label_name):
    df = pd.read_csv(data_file)
    X = df.loc[:, df.columns != y_label_name]
    #y = df.loc[:, df.columns == y_label_name]
    y = df[y_label_name]
    return df, X, y

def create_model (X_train,
                  y_train,
                  X_test,
                  model, 
                  random_state,
                  max_iter):
    
    model = LogisticRegression(random_state = random_state, max_iter = max_iter)
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    return y_pred, model

def makeHeatmap (class_names, cnf_matrix): 
    fig, ax = plt.subplots()
    tick_marks = np.arange(len(class_names))
    plt.xticks(tick_marks, class_names)
    plt.yticks(tick_marks, class_names)
    
    sns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap= "Oranges" ,fmt='g')
    ax.xaxis.set_label_position("bottom")
    plt.tight_layout()
    plt.title('Confusion matrix', y=1.1)
    plt.ylabel('Actual label')
    plt.xlabel('Predicted label');
    
def calcPresRecall (y_test, y_pred, target_names): 
    report = classification_report(y_test, y_pred, target_names = target_names)
    return report

def plotROC (X_test, y_test, model): 
    y_pred_proba = model.predict_proba(X_test)[::,1]
    fpr, tpr, _ = metrics.roc_curve(y_test,  y_pred_proba)
    auc = metrics.roc_auc_score(y_test, y_pred_proba)
    plt.plot(fpr,tpr,label="data 1, auc="+str(auc))
    plt.legend(loc=4)
    plt.show()
```

```{python}
data_file = "data/diabetes_binary_health_indicators_BRFSS2015.csv"
df = pd.read_csv(data_file)
head, shape, missing_values = eda(df)
display(head)
display(shape)
display(missing_values)
df, X, y = prepData(data_file = 'data/diabetes_binary_health_indicators_BRFSS2015.csv',
                        y_label_name = 'Diabetes_binary')
df
```
