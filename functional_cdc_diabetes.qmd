---
jupyter: python3
---

```{python}
# Using Logistic regression as a classifier (Machine Learning) 
```

```{python}
from ucimlrepo import fetch_ucirepo 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from collections import Counter
```

```{python}
# The data

# 253,680 individuals, with 22 features
# This dataset was released by the CDC, Behavioral Risk Factor Surveillance System (BRFSS) is the nation's premier system of health-related telephone surveys that collect state data about U.S. residents regarding their health-related risk behaviors, chronic health conditions, and use of preventive services
# https://www.kaggle.com/datasets/alexteboul/diabetes-health-indicators-dataset

# The model - Logistic regression (Multinomal model) 

# Logistic regression is typically not a classifier however; when using sci-kit learn:
# "The numerical output of the logistic regression, which is the predicted probability, can be used as a classifier by applying a threshold (by default 0.5) to it. 
# This is how it is implemented in scikit-learn, so it expects a categorical target, making the Logistic Regression a classifier."
```

```{python}
# Exploratory data analysis 

def eda (df):
    head = df.head()
    shape = df.shape
    missing_values = df.isnull().sum()
    return head, shape, missing_values

def prepData (data_file, 
              y_label_name):
    df = pd.read_csv(data_file)
    X = df.loc[:, df.columns != y_label_name]
    #y = df.loc[:, df.columns == y_label_name]
    y = df[y_label_name]
    return df, X, y

def create_model (X_train,
                  y_train,
                  X_test,
                  model, 
                  random_state,
                  max_iter):
    
    model = LogisticRegression(random_state = random_state, max_iter = max_iter)
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    return y_pred, model

def makeHeatmap (class_names, cnf_matrix): 
    fig, ax = plt.subplots()
    tick_marks = np.arange(len(class_names))
    plt.xticks(tick_marks, class_names)
    plt.yticks(tick_marks, class_names)
    
    sns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap= "Oranges" ,fmt='g')
    ax.xaxis.set_label_position("bottom")
    plt.tight_layout()
    plt.title('Confusion matrix', y=1.1)
    plt.ylabel('Actual label')
    plt.xlabel('Predicted label');
    
def calcPresRecall (y_test, y_pred, target_names): 
    report = classification_report(y_test, y_pred, target_names = target_names)
    return report

def plotROC (X_test, y_test, model): 
    y_pred_proba = model.predict_proba(X_test)[::,1]
    fpr, tpr, _ = metrics.roc_curve(y_test,  y_pred_proba)
    auc = metrics.roc_auc_score(y_test, y_pred_proba)
    plt.plot(fpr,tpr,label="data 1, auc="+str(auc))
    plt.legend(loc=4)
    plt.show()

data_file = "data/diabetes_binary_health_indicators_BRFSS2015.csv"
df = pd.read_csv(data_file)
head, shape, missing_values = eda(df)
display(head)
display(shape)
display(missing_values)
df, X, y = prepData(data_file = 'data/diabetes_binary_health_indicators_BRFSS2015.csv',
                        y_label_name = 'Diabetes_binary')
df
```
