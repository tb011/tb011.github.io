{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Diabetes Logistic Regression\"\n",
        "format: \n",
        "  html:\n",
        "    code-fold: false\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "## Logistic regression\n",
        " \n",
        "Using Logistic regression as a classifier (Machine Learning) \n"
      ],
      "id": "b05cf5a7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from ucimlrepo import fetch_ucirepo \n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.linear_model import LogisticRegression\n",
        "from sklearn import metrics\n",
        "from sklearn.metrics import classification_report\n",
        "from sklearn.metrics import confusion_matrix\n",
        "from collections import Counter"
      ],
      "id": "5cdf0f1a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-polar\n",
        "#| fig-cap: A line plot on a polar axis\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "r = np.arange(0, 2, 0.01)\n",
        "theta = 2 * np.pi * r\n",
        "fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n",
        "ax.plot(theta, r)\n",
        "ax.set_rticks([0.5, 1, 1.5, 2])\n",
        "ax.grid(True)\n",
        "plt.show()"
      ],
      "id": "fig-polar",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Exploratory data analysis \n",
        "\n",
        "def eda (df):\n",
        "    head = df.head()\n",
        "    shape = df.shape\n",
        "    missing_values = df.isnull().sum()\n",
        "    return head, shape, missing_values\n",
        "\n",
        "def prepData (data_file, \n",
        "              y_label_name):\n",
        "    df = pd.read_csv(data_file)\n",
        "    X = df.loc[:, df.columns != y_label_name]\n",
        "    #y = df.loc[:, df.columns == y_label_name]\n",
        "    y = df[y_label_name]\n",
        "    return df, X, y\n",
        "\n",
        "def create_model (X_train,\n",
        "                  y_train,\n",
        "                  X_test,\n",
        "                  model, \n",
        "                  random_state,\n",
        "                  max_iter):\n",
        "    \n",
        "    model = LogisticRegression(random_state = random_state, max_iter = max_iter)\n",
        "    model.fit(X_train, y_train)\n",
        "    y_pred = model.predict(X_test)\n",
        "    return y_pred, model\n",
        "\n",
        "def makeHeatmap (class_names, cnf_matrix): \n",
        "    fig, ax = plt.subplots()\n",
        "    tick_marks = np.arange(len(class_names))\n",
        "    plt.xticks(tick_marks, class_names)\n",
        "    plt.yticks(tick_marks, class_names)\n",
        "    \n",
        "    sns.heatmap(pd.DataFrame(cnf_matrix), annot=True, cmap= \"Oranges\" ,fmt='g')\n",
        "    ax.xaxis.set_label_position(\"bottom\")\n",
        "    plt.tight_layout()\n",
        "    plt.title('Confusion matrix', y=1.1)\n",
        "    plt.ylabel('Actual label')\n",
        "    plt.xlabel('Predicted label');\n",
        "    \n",
        "def calcPresRecall (y_test, y_pred, target_names): \n",
        "    report = classification_report(y_test, y_pred, target_names = target_names)\n",
        "    return report\n",
        "\n",
        "def plotROC (X_test, y_test, model): \n",
        "    y_pred_proba = model.predict_proba(X_test)[::,1]\n",
        "    fpr, tpr, _ = metrics.roc_curve(y_test,  y_pred_proba)\n",
        "    auc = metrics.roc_auc_score(y_test, y_pred_proba)\n",
        "    plt.plot(fpr,tpr,label=\"data 1, auc=\"+str(auc))\n",
        "    plt.legend(loc=4)\n",
        "    plt.show()"
      ],
      "id": "0c6a815b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "data_file = \"data/diabetes_binary_health_indicators_BRFSS2015.csv\"\n",
        "df = pd.read_csv(data_file)\n",
        "head, shape, missing_values = eda(df)\n",
        "display(head)\n",
        "display(shape)\n",
        "display(missing_values)\n",
        "df, X, y = prepData(data_file = 'data/diabetes_binary_health_indicators_BRFSS2015.csv',\n",
        "                        y_label_name = 'Diabetes_binary')\n",
        "df"
      ],
      "id": "ffd04f32",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\sbztb3\\AppData\\Local\\Programs\\Python\\Python313\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}